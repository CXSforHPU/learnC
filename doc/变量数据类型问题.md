在C语言中，变量的数据类型信息在不同阶段有不同的处理方式：

## 编译时类型信息

### 1. 编译阶段
- **类型检查**：编译器在编译时会检查变量的类型，确保类型兼容性
- **类型信息存储**：类型信息主要存储在编译器的符号表中，不会直接存储在生成的可执行文件中
- **内存分配**：根据类型确定变量所需的内存大小和对齐方式

### 2. 运行时类型信息
对于你提供的代码中的各种变量类型：

#### 基本数据类型
```c
int a = 10;           // 4字节整数（通常）
float f = 3.14f;      // 4字节浮点数
double d = 3.14159;   // 8字节双精度浮点数
char ch = 'A';        // 1字节字符
```

这些变量在内存中只存储值本身，不存储类型信息。

#### 指针类型
```c
int *p = &a;          // 指针变量存储地址值
int arr[5] = {1,2,3,4,5};  // 数组名退化为指针
int (*pAdd)(int, int) = add; // 函数指针
```

指针变量存储的是内存地址，类型信息仅在编译时用于类型检查。

#### 结构体和自定义类型
```c
typedef enum {Int, Double} math_type;
typedef enum {FALSE, TRUE} my_bool;
```

枚举类型在运行时通常以整数形式存储，具体的值对应枚举常量。

## 内存中的存储方式

### 1. 栈内存变量（局部变量）
```c
void test_function() {
    int a = 10;        // 存储在栈中，只存储值10
    int *p = &a;       // 存储变量a的地址
    char str[20];      // 分配20字节的连续内存块
}
```

### 2. 堆内存变量（动态分配）
```c
double *result = (double *)malloc(2 * sizeof(double));
```

堆内存中只存储数据值，类型信息由程序员通过指针类型来维护。

### 3. 全局/静态变量
```c
static my_bool is_fp_zero(double number) { ... }
```

全局和静态变量存储在数据段，同样只存储值本身。

## 函数指针的特殊性

在你的代码中，函数指针的例子：
```c
static int add(int a, int b) {
    return a + b;
}

int test_func_pointer() {
    int (*pAdd)(int a, int b) = add;
}
```

函数指针存储的是函数的入口地址，函数的签名信息（参数类型和返回值类型）只在编译时用于类型检查。

## GDB中观察到的类型信息

当你在GDB中执行：
```gdb
(gdb) p *pAdd
$13 = {int (int, int)} 0x402676 <add>

(gdb) p pAdd
$14 = (int (*)(int, int)) 0x402676 <add>
```

这些类型信息是GDB从可执行文件的调试符号表中读取的，这些信息是在编译时添加到可执行文件中的。

## 总结

1. **运行时**：C语言变量在内存中只存储值，不存储类型信息
2. **编译时**：类型信息存储在编译器符号表和可执行文件的调试信息中
3. **类型安全**：通过编译时检查确保类型正确性
4. **内存布局**：变量根据类型确定内存大小和对齐方式，但运行时只存储值

这就是为什么C语言被称为"弱类型"或"静态类型"语言的原因——类型检查在编译时完成，运行时只关心内存中的值。